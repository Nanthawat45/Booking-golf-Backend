import Booking from '../models/Booking.js';
import Asset from '../models/Asset.js'; // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
import User from '../models/User.js';   // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏™‡πâ‡∏ô‡∏ó‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
import mongoose from 'mongoose';

// --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≠‡∏á Asset ‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô (‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô ID) ---
const reserveAssets = async (assetType, quantity, session) => {
  if (quantity <= 0) {
    return [];
  }

  const availableAssets = await Asset.find({ 
    type: assetType, 
    status: "available" 
  }).limit(quantity).session(session);

  if (availableAssets.length < quantity) {
    throw new Error(`Not enough ${assetType}s available. Requested: ${quantity}, Available: ${availableAssets.length}`);
  }

  const assetIdsToUpdate = availableAssets.map(asset => asset._id);
  
  await Asset.updateMany(
    { _id: { $in: assetIdsToUpdate } },
    { $set: { status: "booked" } },
    { session: session }
  );

  return assetIdsToUpdate;
};

// --- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ä‡πà‡∏ß‡∏¢‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ ---
const reserveCaddies = async (caddyIds, session) => {
  if (!caddyIds || caddyIds.length === 0) {
    return []; // ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ array ‡∏ß‡πà‡∏≤‡∏á ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ
  }

  // ‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ‡πÅ‡∏•‡∏∞‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ role ‡πÄ‡∏õ‡πá‡∏ô 'caddy' ‡πÅ‡∏•‡∏∞ status ‡πÄ‡∏õ‡πá‡∏ô 'available'
  const availableCaddies = await User.find({
    _id: { $in: caddyIds },
    role: 'caddy',
    caddyStatus: 'available'
  }).session(session);

  // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏°‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏£‡∏¥‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
  if (availableCaddies.length !== caddyIds.length) {
    const bookedCaddyIds = availableCaddies.map(caddy => caddy._id.toString());
    const unavailableRequestedCaddyIds = caddyIds.filter(id => !bookedCaddyIds.includes(id.toString()));
    throw new Error(`Some selected caddies are not available or do not exist/are not caddies: ${unavailableRequestedCaddyIds.join(', ')}`);
  }

  // ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏à‡∏≠‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô "booked"
  await User.updateMany(
    { _id: { $in: caddyIds } },
    { $set: { caddyStatus: "booked" } },
    { session: session }
  );

  return caddyIds; // ‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô ID ‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏à‡∏≠‡∏á‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
};


// --- üîπ ‡∏à‡∏≠‡∏á‡πÄ‡∏ß‡∏•‡∏≤‡∏≠‡∏≠‡∏Å‡∏£‡∏≠‡∏ö (Book Slot) ---
export const bookSlot = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { 
      courseType, 
      date, 
      timeSlot, 
      players, 
      groupName, 
      caddy, 
      totalPrice, 
      golfCartQty = 0, 
      golfBagQty = 0,   
    } = req.body;

    const bookedGolfCartIds = await reserveAssets("golfCart", golfCartQty, session);
    const bookedGolfBagIds = await reserveAssets("golfBag", golfBagQty, session);
    const bookedCaddyIds = await reserveCaddies(caddy, session); 

    const booking = new Booking({
      user: req.user._id, 
      courseType,
      date,
      timeSlot,
      players,
      groupName,
      caddy: bookedCaddyIds, 
      totalPrice,
      isPaid: false,
      golfCartQty,
      golfBagQty,
      bookedGolfCartIds: bookedGolfCartIds, 
      bookedGolfBagIds: bookedGolfBagIds,   
    });

    await booking.save({ session });

    await session.commitTransaction();

    res.status(201).json({ message: "Booking Successful", booking });

  } catch (error) {
    await session.abortTransaction();
    console.error("Booking failed:", error);
    res.status(400).json({ error: error.message || "Failed to make booking." });
  } finally {
    session.endSession();
  }
};

// --- üîπ ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ---
export const getBookings = async (req, res) => {
  try {
    const bookings = await Booking.find()
      .populate('caddy', 'name email caddyStatus') 
      .populate('bookedGolfCartIds', 'name type status') 
      .populate('bookedGolfBagIds', 'name type status'); 
    res.json(bookings);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// --- üîπ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏£‡∏ß‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ ‡∏´‡∏£‡∏∑‡∏≠ Asset) ---
export const updateBooking = async (req, res) => {
  try {
    const booking = await Booking.findById(req.params.id);

    if (!booking) {
      return res.status(404).json({ message: "Booking not found" });
    }

    if (req.body.timeSlot) {
      booking.timeSlot = req.body.timeSlot;
    } else {
      return res.status(400).json({ message: "Only 'timeSlot' can be updated for this endpoint" });
    }

    const updatedBooking = await booking.save();

    res.status(200).json({ message: "Booking updated successfully", booking: updatedBooking });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
};

// --- üîπ ‡∏•‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á (Admin/Staff) ---
export const deleteBooking = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();
  try {
    const booking = await Booking.findById(req.params.id).session(session);
    if (!booking) {
      return res.status(404).json({ message: "Booking not found" });
    }
    
    // ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Asset
    if (booking.bookedGolfCartIds.length > 0) {
      await Asset.updateMany(
        { _id: { $in: booking.bookedGolfCartIds } },
        { $set: { status: "available" } },
        { session: session }
      );
    }
    if (booking.bookedGolfBagIds.length > 0) {
      await Asset.updateMany(
        { _id: { $in: booking.bookedGolfBagIds } },
        { $set: { status: "available" } },
        { session: session }
      );
    }

    // ‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Caddy
    if (booking.caddy.length > 0) {
        await User.updateMany(
            { _id: { $in: booking.caddy } },
            { $set: { caddyStatus: "available" } }, 
            { session: session }
        );
    }

    await booking.deleteOne({ session });

    await session.commitTransaction();
    res.status(200).json({ message: "Booking deleted successfully, assets and caddies returned to available." });
  } catch (error) {
    await session.abortTransaction();
    console.error("Error deleting booking:", error);
    res.status(500).json({ error: error.message || "Failed to delete booking." });
  } finally {
    session.endSession();
  }
};

// --- ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô: ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏á‡∏≤‡∏ô (Start Round) ---
export const startRound = async (req, res) => {
  const { bookingId } = req.params;
  const caddyId = req.user._id; // ID ‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const booking = await Booking.findById(bookingId).session(session);

    if (!booking) {
      return res.status(404).json({ message: "Booking not found." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!booking.caddy.map(id => id.toString()).includes(caddyId.toString())) {
        return res.status(403).json({ message: "You are not assigned to this booking." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á Asset ‡πÅ‡∏•‡∏∞ Caddy ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
    const currentCaddy = await User.findById(caddyId).session(session);
    if (!currentCaddy || currentCaddy.caddyStatus !== 'booked') {
      throw new Error("Caddy is not in 'booked' status or not found.");
    }

    // 1. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á Golf Carts ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'inUse'
    if (booking.bookedGolfCartIds && booking.bookedGolfCartIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfCartIds }, status: 'booked' },
        { $set: { status: 'inUse' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfCartIds.length) {
          throw new Error("Not all golf carts were in 'booked' status or updated.");
      }
    }

    // 2. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á Golf Bags ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'inUse'
    if (booking.bookedGolfBagIds && booking.bookedGolfBagIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfBagIds }, status: 'booked' },
        { $set: { status: 'inUse' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfBagIds.length) {
          throw new Error("Not all golf bags were in 'booked' status or updated.");
      }
    }

    // 3. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'onDuty'
    await User.updateOne(
      { _id: caddyId, caddyStatus: 'booked' },
      { $set: { caddyStatus: 'onDuty' } },
      { session: session }
    );

    await session.commitTransaction();
    res.status(200).json({ message: "Round started successfully. Assets and caddy are now in use.", booking });

  } catch (error) {
    await session.abortTransaction();
    console.error("Failed to start round:", error);
    res.status(400).json({ error: error.message || "Failed to start round." });
  } finally {
    session.endSession();
  }
};

// --- ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô: ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏à‡∏ö‡∏á‡∏≤‡∏ô (End Round) ---
export const endRound = async (req, res) => {
  const { bookingId } = req.params;
  const caddyId = req.user._id; // ID ‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const booking = await Booking.findById(bookingId).session(session);

    if (!booking) {
      return res.status(404).json({ message: "Booking not found." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!booking.caddy.map(id => id.toString()).includes(caddyId.toString())) {
        return res.status(403).json({ message: "You are not assigned to this booking." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á Asset ‡πÅ‡∏•‡∏∞ Caddy ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
    const currentCaddy = await User.findById(caddyId).session(session);
    if (!currentCaddy || currentCaddy.caddyStatus !== 'onDuty') {
      throw new Error("Caddy is not in 'onDuty' status or not found.");
    }

    // 1. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á Golf Carts ‡∏à‡∏≤‡∏Å 'inUse' ‡πÄ‡∏õ‡πá‡∏ô 'clean'
    if (booking.bookedGolfCartIds && booking.bookedGolfCartIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfCartIds }, status: 'inUse' },
        { $set: { status: 'clean' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfCartIds.length) {
          throw new Error("Not all golf carts were in 'inUse' status or updated.");
      }
    }

    // 2. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á Golf Bags ‡∏à‡∏≤‡∏Å 'inUse' ‡πÄ‡∏õ‡πá‡∏ô 'clean'
    if (booking.bookedGolfBagIds && booking.bookedGolfBagIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfBagIds }, status: 'inUse' },
        { $set: { status: 'clean' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfBagIds.length) {
          throw new Error("Not all golf bags were in 'inUse' status or updated.");
      }
    }

    // 3. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏à‡∏≤‡∏Å 'onDuty' ‡πÄ‡∏õ‡πá‡∏ô 'cleaning'
    await User.updateOne(
      { _id: caddyId, caddyStatus: 'onDuty' },
      { $set: { caddyStatus: 'cleaning' } },
      { session: session }
    );

    await session.commitTransaction();
    res.status(200).json({ message: "Round ended successfully. Assets are now clean and caddy is cleaning.", booking });

  } catch (error) {
    await session.abortTransaction();
    console.error("Failed to end round:", error);
    res.status(400).json({ error: error.message || "Failed to end round." });
  } finally {
    session.endSession();
  }
};

// --- ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°" (Cancel Before Start) ---
export const cancelBeforeStart = async (req, res) => {
  const { bookingId } = req.params;
  const caddyId = req.user._id;

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const booking = await Booking.findById(bookingId).session(session);

    if (!booking) {
      return res.status(404).json({ message: "Booking not found." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!booking.caddy.map(id => id.toString()).includes(caddyId.toString())) {
        return res.status(403).json({ message: "You are not assigned to this booking." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô 'booked' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
    const currentCaddy = await User.findById(caddyId).session(session);
    if (!currentCaddy || currentCaddy.caddyStatus !== 'booked') {
      throw new Error("Caddy is not in 'booked' status. Cannot cancel before start.");
    }

    // 1. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Golf Carts ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'available'
    if (booking.bookedGolfCartIds && booking.bookedGolfCartIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfCartIds }, status: 'booked' },
        { $set: { status: 'available' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfCartIds.length) {
          console.warn("Not all golf carts were in 'booked' status for cancellation.");
      }
    }

    // 2. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Golf Bags ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'available'
    if (booking.bookedGolfBagIds && booking.bookedGolfBagIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfBagIds }, status: 'booked' },
        { $set: { status: 'available' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfBagIds.length) {
          console.warn("Not all golf bags were in 'booked' status for cancellation.");
      }
    }

    // 3. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏à‡∏≤‡∏Å 'booked' ‡πÄ‡∏õ‡πá‡∏ô 'available'
    await User.updateOne(
      { _id: caddyId, caddyStatus: 'booked' },
      { $set: { caddyStatus: 'available' } },
      { session: session }
    );

    // 4. "‡∏õ‡∏•‡∏î" ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡πÅ‡∏•‡∏∞ Asset ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Booking ‡∏ô‡∏±‡πâ‡∏ô
    booking.caddy = []; 
    booking.bookedGolfCartIds = [];
    booking.bookedGolfBagIds = [];
    await booking.save({ session });

    await session.commitTransaction();
    res.status(200).json({ message: "Booking cancelled before start. Assets and caddy are now available.", booking });

  } catch (error) {
    await session.abortTransaction();
    console.error("Failed to cancel booking before start:", error);
    res.status(400).json({ error: error.message || "Failed to cancel booking before start." });
  } finally {
    session.endSession();
  }
};

// --- ‚úÖ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ "‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏ó‡∏≥" (Cancel During Round) ---
export const cancelDuringRound = async (req, res) => {
  const { bookingId } = req.params;
  const caddyId = req.user._id;

  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const booking = await Booking.findById(bookingId).session(session);

    if (!booking) {
      return res.status(404).json({ message: "Booking not found." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏ó‡∏µ‡πà‡∏•‡πá‡∏≠‡∏Å‡∏≠‡∏¥‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏ñ‡∏π‡∏Å‡∏°‡∏≠‡∏ö‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏à‡∏≠‡∏á‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
    if (!booking.caddy.map(id => id.toString()).includes(caddyId.toString())) {
        return res.status(403).json({ message: "You are not assigned to this booking." });
    }

    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ (‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏õ‡πá‡∏ô 'onDuty' ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)
    const currentCaddy = await User.findById(caddyId).session(session);
    if (!currentCaddy || currentCaddy.caddyStatus !== 'onDuty') {
      throw new Error("Caddy is not in 'onDuty' status. Cannot cancel during round.");
    }

    // 1. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Golf Carts ‡∏à‡∏≤‡∏Å 'inUse' ‡πÄ‡∏õ‡πá‡∏ô 'clean'
    if (booking.bookedGolfCartIds && booking.bookedGolfCartIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfCartIds }, status: 'inUse' },
        { $set: { status: 'clean' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfCartIds.length) {
          console.warn("Not all golf carts were in 'inUse' status for cancellation.");
      }
    }

    // 2. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ Golf Bags ‡∏à‡∏≤‡∏Å 'inUse' ‡πÄ‡∏õ‡πá‡∏ô 'clean'
    if (booking.bookedGolfBagIds && booking.bookedGolfBagIds.length > 0) {
      const result = await Asset.updateMany(
        { _id: { $in: booking.bookedGolfBagIds }, status: 'inUse' },
        { $set: { status: 'clean' } },
        { session: session }
      );
      if (result.modifiedCount !== booking.bookedGolfBagIds.length) {
          console.warn("Not all golf bags were in 'inUse' status for cancellation.");
      }
    }

    // 3. ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡∏à‡∏≤‡∏Å 'onDuty' ‡πÄ‡∏õ‡πá‡∏ô 'cleaning'
    await User.updateOne(
      { _id: caddyId, caddyStatus: 'onDuty' },
      { $set: { caddyStatus: 'cleaning' } },
      { session: session }
    );

    // 4. "‡∏õ‡∏•‡∏î" ‡πÅ‡∏Ñ‡∏î‡∏î‡∏µ‡πâ‡πÅ‡∏•‡∏∞ Asset ‡∏≠‡∏≠‡∏Å‡∏à‡∏≤‡∏Å Booking ‡∏ô‡∏±‡πâ‡∏ô
    booking.caddy = [];
    booking.bookedGolfCartIds = [];
    booking.bookedGolfBagIds = [];
    await booking.save({ session });

    await session.commitTransaction();
    res.status(200).json({ message: "Round cancelled during play. Assets are now clean and caddy is cleaning.", booking });

  } catch (error) {
    await session.abortTransaction();
    console.error("Failed to cancel booking during round:", error);
    res.status(400).json({ error: error.message || "Failed to cancel booking during round." });
  } finally {
    session.endSession();
  }
};